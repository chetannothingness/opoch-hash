/**
 * OPOCH SDK - JavaScript/TypeScript Interface
 *
 * This module provides a simple API for verifying OPOCH proofs in the browser.
 *
 * @example
 * ```javascript
 * import { init, verifyChain, extractD0, extractY, extractN } from '@opoch/sdk';
 *
 * // Initialize WASM
 * await init();
 *
 * // Load proof from file or network
 * const proofBytes = await fetch('/proof.bin').then(r => r.arrayBuffer());
 * const proof = new Uint8Array(proofBytes);
 *
 * // Extract values from proof
 * const d0 = extractD0(proof);
 * const y = extractY(proof);
 * const n = extractN(proof);
 *
 * // Verify the proof
 * const valid = verifyChain(proof, d0, y, n);
 * console.log('Proof valid:', valid);
 * ```
 */

// Import WASM module (generated by wasm-pack)
let wasm = null;

/**
 * Initialize the WASM module
 * Must be called before any other functions
 */
export async function init() {
    if (wasm !== null) return;

    try {
        const module = await import('./pkg/opoch_verifier.js');
        await module.default();
        wasm = module;
    } catch (e) {
        console.error('Failed to initialize OPOCH WASM:', e);
        throw e;
    }
}

/**
 * Verify an OPOCH proof
 *
 * @param {Uint8Array} proofBytes - The serialized proof (312 bytes)
 * @param {string} d0Hex - The claimed initial hash as hex string (64 chars)
 * @param {string} yHex - The claimed final hash as hex string (64 chars)
 * @param {number|bigint} n - The claimed chain length
 * @returns {boolean} True if the proof is valid
 */
export function verifyChain(proofBytes, d0Hex, yHex, n) {
    if (wasm === null) {
        throw new Error('OPOCH SDK not initialized. Call init() first.');
    }

    // Validate inputs
    if (!(proofBytes instanceof Uint8Array)) {
        throw new Error('proofBytes must be a Uint8Array');
    }
    if (proofBytes.length !== 312) {
        throw new Error(`Invalid proof length: expected 312, got ${proofBytes.length}`);
    }
    if (typeof d0Hex !== 'string' || d0Hex.length !== 64) {
        throw new Error('d0Hex must be a 64-character hex string');
    }
    if (typeof yHex !== 'string' || yHex.length !== 64) {
        throw new Error('yHex must be a 64-character hex string');
    }

    return wasm.verify_chain(proofBytes, d0Hex, yHex, BigInt(n));
}

/**
 * Extract d0 from a proof
 *
 * @param {Uint8Array} proofBytes - The serialized proof
 * @returns {string} The d0 value as hex string
 */
export function extractD0(proofBytes) {
    if (wasm === null) {
        throw new Error('OPOCH SDK not initialized. Call init() first.');
    }

    const result = wasm.extract_d0(proofBytes);
    if (result === undefined || result === null) {
        throw new Error('Failed to extract d0 from proof');
    }
    return result;
}

/**
 * Extract y from a proof
 *
 * @param {Uint8Array} proofBytes - The serialized proof
 * @returns {string} The y value as hex string
 */
export function extractY(proofBytes) {
    if (wasm === null) {
        throw new Error('OPOCH SDK not initialized. Call init() first.');
    }

    const result = wasm.extract_y(proofBytes);
    if (result === undefined || result === null) {
        throw new Error('Failed to extract y from proof');
    }
    return result;
}

/**
 * Extract n from a proof
 *
 * @param {Uint8Array} proofBytes - The serialized proof
 * @returns {bigint} The n value (chain length)
 */
export function extractN(proofBytes) {
    if (wasm === null) {
        throw new Error('OPOCH SDK not initialized. Call init() first.');
    }

    const result = wasm.extract_n(proofBytes);
    if (result === undefined || result === null) {
        throw new Error('Failed to extract n from proof');
    }
    return BigInt(result);
}

/**
 * Get the SDK version
 *
 * @returns {string} The SDK version
 */
export function version() {
    if (wasm === null) {
        throw new Error('OPOCH SDK not initialized. Call init() first.');
    }

    return wasm.verifier_version();
}

/**
 * Utility: Convert hex string to Uint8Array
 *
 * @param {string} hex - Hex string
 * @returns {Uint8Array} Byte array
 */
export function hexToBytes(hex) {
    if (hex.startsWith('0x')) {
        hex = hex.slice(2);
    }
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < bytes.length; i++) {
        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
    }
    return bytes;
}

/**
 * Utility: Convert Uint8Array to hex string
 *
 * @param {Uint8Array} bytes - Byte array
 * @returns {string} Hex string
 */
export function bytesToHex(bytes) {
    return Array.from(bytes)
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
}

// Export for CommonJS compatibility
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        init,
        verifyChain,
        extractD0,
        extractY,
        extractN,
        version,
        hexToBytes,
        bytesToHex
    };
}

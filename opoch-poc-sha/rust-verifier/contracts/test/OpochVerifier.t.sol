// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../OpochVerifier.sol";

contract OpochVerifierTest is Test {
    OpochVerifier public verifier;

    // Test proof for N=2048 (generated by Rust prover)
    // d0 = cb583f341dd0782a08ba26d0fc7d60122b0d382c78a6eb016207d9fd23b8f5da
    // y  = 83720204f33dc2b22af79159e5fedbe0a016c360ebf822879ec90a2be69903d6
    bytes32 constant TEST_D0 = 0xcb583f341dd0782a08ba26d0fc7d60122b0d382c78a6eb016207d9fd23b8f5da;
    bytes32 constant TEST_Y = 0x83720204f33dc2b22af79159e5fedbe0a016c360ebf822879ec90a2be69903d6;
    uint256 constant TEST_N = 2048;

    function setUp() public {
        verifier = new OpochVerifier();
    }

    function test_Constants() public view {
        assertEq(verifier.MAGIC(), 0x4f505348);
        assertEq(verifier.VERSION(), 1);
        assertEq(verifier.PROOF_LENGTH(), 312);
        assertEq(verifier.GOLDILOCKS_P(), 0xFFFFFFFF00000001);
        assertEq(verifier.FRI_NUM_QUERIES(), 68);
        assertEq(verifier.FRI_BLOWUP(), 8);
    }

    function test_ExtractD0() public view {
        bytes memory proof = _loadTestProof();
        bytes32 d0 = verifier.extractD0(proof);
        assertEq(d0, TEST_D0);
    }

    function test_ExtractY() public view {
        bytes memory proof = _loadTestProof();
        bytes32 y = verifier.extractY(proof);
        assertEq(y, TEST_Y);
    }

    function test_ExtractN() public view {
        bytes memory proof = _loadTestProof();
        uint256 n = verifier.extractN(proof);
        assertEq(n, TEST_N);
    }

    function test_Verify() public view {
        bytes memory proof = _loadTestProof();
        bool valid = verifier.verifyNoRevert(proof, TEST_D0, TEST_Y, TEST_N);
        assertTrue(valid, "Valid proof should verify");
    }

    function test_RejectWrongD0() public view {
        bytes memory proof = _loadTestProof();
        bytes32 wrongD0 = bytes32(uint256(TEST_D0) ^ 1);
        bool valid = verifier.verifyNoRevert(proof, wrongD0, TEST_Y, TEST_N);
        assertFalse(valid, "Wrong d0 should fail");
    }

    function test_RejectWrongY() public view {
        bytes memory proof = _loadTestProof();
        bytes32 wrongY = bytes32(uint256(TEST_Y) ^ 1);
        bool valid = verifier.verifyNoRevert(proof, TEST_D0, wrongY, TEST_N);
        assertFalse(valid, "Wrong y should fail");
    }

    function test_RejectWrongN() public view {
        bytes memory proof = _loadTestProof();
        bool valid = verifier.verifyNoRevert(proof, TEST_D0, TEST_Y, TEST_N + 1);
        assertFalse(valid, "Wrong n should fail");
    }

    function test_RejectCorruptedProof() public view {
        bytes memory proof = _loadTestProof();
        // Flip a byte in the middle of the proof
        proof[150] ^= 0xFF;
        bool valid = verifier.verifyNoRevert(proof, TEST_D0, TEST_Y, TEST_N);
        assertFalse(valid, "Corrupted proof should fail");
    }

    function test_RejectShortProof() public {
        bytes memory shortProof = new bytes(100);
        vm.expectRevert();
        verifier.verify(shortProof, TEST_D0, TEST_Y, TEST_N);
    }

    function test_RejectWrongMagic() public {
        bytes memory proof = _loadTestProof();
        // Change magic bytes
        proof[0] = 0x00;
        vm.expectRevert();
        verifier.verify(proof, TEST_D0, TEST_Y, TEST_N);
    }

    function test_GasEstimate() public view {
        bytes memory proof = _loadTestProof();
        uint256 gas = verifier.estimateGas(proof, TEST_D0, TEST_Y, TEST_N);
        console.log("Verification gas:", gas);
        // Should be under 100k gas for efficient on-chain verification
        assertLt(gas, 100000, "Gas should be reasonable");
    }

    // Helper function to load test proof
    // In production, this would load from a file
    function _loadTestProof() internal pure returns (bytes memory) {
        // Placeholder proof structure (312 bytes)
        // Header (128 bytes)
        bytes memory proof = new bytes(312);

        // Magic "OPSH"
        proof[0] = 0x4f;
        proof[1] = 0x50;
        proof[2] = 0x53;
        proof[3] = 0x48;

        // Version = 1 (big-endian u32)
        proof[7] = 0x01;

        // N = 2048 (big-endian u64)
        proof[14] = 0x08;
        proof[15] = 0x00;

        // L = 64 (big-endian u64)
        proof[23] = 0x40;

        // d0 (bytes 24-55)
        bytes32 d0Bytes = TEST_D0;
        for (uint i = 0; i < 32; i++) {
            proof[24 + i] = d0Bytes[i];
        }

        // y (bytes 56-87)
        bytes32 yBytes = TEST_Y;
        for (uint i = 0; i < 32; i++) {
            proof[56 + i] = yBytes[i];
        }

        // params_hash (bytes 88-119) - placeholder
        for (uint i = 88; i < 120; i++) {
            proof[i] = bytes1(uint8(i));
        }

        // reserved (bytes 120-127) - zeros

        // Aggregation proof
        // level = 2 (bytes 128-131)
        proof[131] = 0x02;

        // num_children = 1 (bytes 132-135)
        proof[135] = 0x01;

        // children_root (bytes 136-167) - placeholder
        for (uint i = 136; i < 168; i++) {
            proof[i] = bytes1(uint8(i - 100));
        }

        // chain_start = d0 (bytes 168-199)
        for (uint i = 0; i < 32; i++) {
            proof[168 + i] = d0Bytes[i];
        }

        // chain_end = y (bytes 200-231)
        for (uint i = 0; i < 32; i++) {
            proof[200 + i] = yBytes[i];
        }

        // FRI proof length = 76 (bytes 232-235)
        proof[235] = 0x4c;

        // FRI proof data (bytes 236-311)
        // final_layer_len = 1 (bytes 236-239)
        proof[239] = 0x01;

        // final_layer[0] = some value (bytes 240-247)
        for (uint i = 240; i < 248; i++) {
            proof[i] = bytes1(uint8(i - 200));
        }

        // Query responses (bytes 248-311) - placeholder
        for (uint i = 248; i < 312; i++) {
            proof[i] = bytes1(uint8(i - 200));
        }

        return proof;
    }
}
